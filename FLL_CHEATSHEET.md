# üéØ FLL ‚Äî –ö—Ä–∞—Ç–∫–∞—è —à–ø–∞—Ä–≥–∞–ª–∫–∞

## –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ–æ—Ä–º—É–ª—ã

### 1. Frequency Error Detector

| –ú–µ—Ç–æ–¥ | –§–æ—Ä–º—É–ª–∞ | –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ |
|-------|---------|-----------|
| **Cross-Product** | `e[n] = Im(s[n]¬∑s*[n-1])` | –ú–∞–ª—ã–µ –æ—à–∏–±–∫–∏, –±—ã—Å—Ç—Ä–æ |
| **Atan2** | `e[n] = atan2(Im(p), Re(p))`<br>–≥–¥–µ `p = s[n]¬∑s*[n-1]` | –ë–æ–ª—å—à–∏–µ –æ—à–∏–±–∫–∏ |
| **Decision-Directed** | `e[n] = Im((s[n]¬∑≈ù*[n])¬∑(s*[n-1]¬∑≈ù[n-1]))`<br>–≥–¥–µ `≈ù = decision(s)` | –í—ã—Å–æ–∫–∏–π SNR, –∏–∑–≤–µ—Å—Ç–Ω–∞—è –º–æ–¥—É–ª—è—Ü–∏—è |

### 2. Loop Filter (PI-–∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä)

```
integrator[n] = integrator[n-1] + Ki¬∑e[n]
u[n] = Kp¬∑e[n] + integrator[n]
```

### 3. NCO

```
phase[n+1] = phase[n] + 2œÄ¬∑freq[n]
correction[n] = e^(-j¬∑phase[n])
s_corrected[n] = s[n]¬∑correction[n]
```

---

## –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç

### –®–∞–≥ 1: –ò–º–ø–æ—Ä—Ç

```python
from fll import FrequencyLockedLoop
import numpy as np
```

### –®–∞–≥ 2: –°–æ–∑–¥–∞–Ω–∏–µ FLL

```python
fll = FrequencyLockedLoop(
    detector_method='cross_product',  # –∏–ª–∏ 'atan2', 'decision_directed'
    Kp=0.001,                          # –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç
    Ki=0.00005,                        # –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç
    freq_limit=0.1                     # ¬±10% –æ—Ç —á–∞—Å—Ç–æ—Ç—ã –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏
)
```

### –®–∞–≥ 3: –û–±—Ä–∞–±–æ—Ç–∫–∞

```python
# –í–µ—Å—å —Å–∏–≥–Ω–∞–ª —Å—Ä–∞–∑—É
corrected_signal, freq_estimate = fll.process_signal(signal)

# –ò–õ–ò –æ—Ç—Å—á—ë—Ç –∑–∞ –æ—Ç—Å—á—ë—Ç–æ–º
for sample in signal:
    corrected_sample = fll.process_sample(sample)
```

### –®–∞–≥ 4: –†–µ–∑—É–ª—å—Ç–∞—Ç—ã

```python
print(f"–ß–∞—Å—Ç–æ—Ç–Ω—ã–π —Å–¥–≤–∏–≥: {fll.get_frequency_estimate()}")
fll.plot_performance()  # –≥—Ä–∞—Ñ–∏–∫–∏
```

---

## –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤

### –í—ã–±–æ—Ä –º–µ—Ç–æ–¥–∞

```
SNR < 10 –¥–ë          ‚Üí cross_product
SNR > 15 –¥–ë + QPSK   ‚Üí decision_directed
–ë–æ–ª—å—à–∞—è –æ—à–∏–±–∫–∞ (>5%) ‚Üí atan2
```

### –†–∞—Å—á—ë—Ç Kp –∏ Ki

**–ú–µ—Ç–æ–¥ 1: –ü–æ –ø–æ–ª–æ—Å–µ –ø–µ—Ç–ª–∏**

```python
BnT = 0.01  # –∂–µ–ª–∞–µ–º–∞—è –ø–æ–ª–æ—Å–∞ (1%)
zeta = 0.707  # –¥–µ–º–ø—Ñ–∏—Ä–æ–≤–∞–Ω–∏–µ

theta = BnT / (zeta + 1/(4*zeta))
Kp = theta
Ki = theta**2 / 4
```

**–ú–µ—Ç–æ–¥ 2: –≠–º–ø–∏—Ä–∏—á–µ—Å–∫–∏**

| –¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ | Kp | Ki |
|------------|----|----|
| –ë—ã—Å—Ç—Ä–∞—è —Å—Ö–æ–¥–∏–º–æ—Å—Ç—å | 0.005...0.01 | 0.0001...0.001 |
| –°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å | 0.0001...0.001 | 0.00001...0.0001 |
| –ù–∏–∑–∫–∏–π SNR | < 0.0005 | < 0.00001 |

---

## –¢–∏–ø–∏—á–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã

| –ü—Ä–æ–±–ª–µ–º–∞ | –ü—Ä–∏—á–∏–Ω–∞ | –†–µ—à–µ–Ω–∏–µ |
|----------|---------|---------|
| üî¥ –ù–µ —Å—Ö–æ–¥–∏—Ç—Å—è | –°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏–µ Kp/Ki | –£–º–µ–Ω—å—à–∏—Ç—å –≤ 10 —Ä–∞–∑ |
| üî¥ –û—Å—Ü–∏–ª–ª—è—Ü–∏–∏ | –ù–∏–∑–∫–æ–µ –¥–µ–º–ø—Ñ–∏—Ä–æ–≤–∞–Ω–∏–µ | –£–º–µ–Ω—å—à–∏—Ç—å Kp, —É–≤–µ–ª–∏—á–∏—Ç—å Ki/Kp |
| üü° –ú–µ–¥–ª–µ–Ω–Ω–æ | –ú–∞–ª—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã | –£–≤–µ–ª–∏—á–∏—Ç—å Kp |
| üü° –û—Å—Ç–∞—Ç–æ—á–Ω–∞—è –æ—à–∏–±–∫–∞ | –ù–µ—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ç–æ—Ä–∞ | –£–≤–µ–ª–∏—á–∏—Ç—å Ki |
| üî¥ –†–∞—Å—Ö–æ–¥–∏—Ç—Å—è | –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ | –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –¥—Ä—É–≥–æ–π –¥–µ—Ç–µ–∫—Ç–æ—Ä |

---

## –ü—Ä–∏–º–µ—Ä—ã –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤

### –í—ã—Å–æ–∫–∏–π SNR (>15 –¥–ë)

```python
fll = FrequencyLockedLoop(
    detector_method='decision_directed',
    Kp=0.005,
    Ki=0.0001,
    freq_limit=0.1
)
```

### –°—Ä–µ–¥–Ω–∏–π SNR (10-15 –¥–ë)

```python
fll = FrequencyLockedLoop(
    detector_method='cross_product',
    Kp=0.001,
    Ki=0.00005,
    freq_limit=0.1
)
```

### –ù–∏–∑–∫–∏–π SNR (<10 –¥–ë)

```python
fll = FrequencyLockedLoop(
    detector_method='cross_product',
    Kp=0.0002,
    Ki=0.00001,
    freq_limit=0.05
)
```

### –ë–æ–ª—å—à–æ–π —á–∞—Å—Ç–æ—Ç–Ω—ã–π —Å–¥–≤–∏–≥

```python
fll = FrequencyLockedLoop(
    detector_method='atan2',
    Kp=0.002,
    Ki=0.0001,
    freq_limit=0.3  # –±–æ–ª—å—à–µ!
)
```

---

## –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞

### –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏

```python
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 4))

# –ß–∞—Å—Ç–æ—Ç–∞ –≤–æ –≤—Ä–µ–º–µ–Ω–∏
plt.subplot(1, 2, 1)
plt.plot(fll.history['freq_estimates'])
plt.title('–û—Ü–µ–Ω–∫–∞ —á–∞—Å—Ç–æ—Ç—ã')
plt.xlabel('–û—Ç—Å—á—ë—Ç')
plt.grid(True)

# –û—à–∏–±–∫–∞ –≤–æ –≤—Ä–µ–º–µ–Ω–∏
plt.subplot(1, 2, 2)
plt.plot(fll.history['errors'])
plt.title('–û—à–∏–±–∫–∞')
plt.xlabel('–û—Ç—Å—á—ë—Ç')
plt.grid(True)

plt.tight_layout()
plt.show()
```

**–•–æ—Ä–æ—à–∞—è —Å—Ö–æ–¥–∏–º–æ—Å—Ç—å:**
- –ß–∞—Å—Ç–æ—Ç–∞ —Å—Ç–∞–±–∏–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è –∑–∞ 100-500 –æ—Ç—Å—á—ë—Ç–æ–≤
- –û—à–∏–±–∫–∞ —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è –∏ –∫–æ–ª–µ–±–ª–µ—Ç—Å—è –æ–∫–æ–ª–æ –Ω—É–ª—è

**–ü–ª–æ—Ö–∞—è —Å—Ö–æ–¥–∏–º–æ—Å—Ç—å:**
- –ß–∞—Å—Ç–æ—Ç–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç —Ä–∞—Å—Ç–∏/—É–º–µ–Ω—å—à–∞—Ç—å—Å—è
- –ë–æ–ª—å—à–∏–µ –æ—Å—Ü–∏–ª–ª—è—Ü–∏–∏ –æ—à–∏–±–∫–∏
- –û—à–∏–±–∫–∞ –Ω–µ —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è

---

## –ü–æ–ª–µ–∑–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã

```python
# –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è
fll.reset()

# –¢–µ–∫—É—â–∞—è —á–∞—Å—Ç–æ—Ç–∞
freq = fll.get_frequency_estimate()

# –ò—Å—Ç–æ—Ä–∏—è (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
errors = fll.history['errors']
freqs = fll.history['freq_estimates']
phases = fll.history['phases']

# –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
fll.plot_performance()
```

---

## –ö–æ–º–±–∏–Ω–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–≤

### FLL + –û—Ü–µ–Ω–∫–∞ –ø–æ –ø—Ä–µ–∞–º–±—É–ª–µ

```python
# 1. –ì—Ä—É–±–∞—è –æ—Ü–µ–Ω–∫–∞ –ø–æ –ø—Ä–µ–∞–º–±—É–ª–µ
from f_rel import estimate_freq_by_preamble
f_rough = estimate_freq_by_preamble(signal, preamble)

# 2. –ü—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä—É–±—É—é –∫–æ—Ä—Ä–µ–∫—Ü–∏—é
n = np.arange(len(signal))
signal_corrected = signal * np.exp(-1j * 2 * np.pi * f_rough * n)

# 3. FLL –¥–ª—è —Ç–æ—á–Ω–æ–π –ø–æ–¥—Å—Ç—Ä–æ–π–∫–∏
fll = FrequencyLockedLoop(Kp=0.0005, Ki=0.00001)
signal_fine, f_fine = fll.process_signal(signal_corrected)

# –ò—Ç–æ–≥–æ–≤–∞—è —á–∞—Å—Ç–æ—Ç–∞
f_total = f_rough + f_fine
```

### –ö–∞—Å–∫–∞–¥ FLL ‚Üí PLL

```python
# 1. FLL –¥–ª—è –≥—Ä—É–±–æ–π –∫–æ—Ä—Ä–µ–∫—Ü–∏–∏ —á–∞—Å—Ç–æ—Ç—ã
fll = FrequencyLockedLoop(Kp=0.001, Ki=0.00005)
signal_fll, _ = fll.process_signal(signal)

# 2. PLL –¥–ª—è —Ç–æ—á–Ω–æ–π —Ñ–∞–∑–æ–≤–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
from pll import PhaseLockedLoop  # (–µ—Å–ª–∏ –µ—Å—Ç—å)
pll = PhaseLockedLoop(Kp=0.01, Ki=0.001)
signal_pll, _ = pll.process_signal(signal_fll)
```

---

## –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å–ø—Ä–∞–≤–∫–∞

### –ü–µ—Ä–µ–¥–∞—Ç–æ—á–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–µ—Ç–ª–∏

–î–ª—è PI-–∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞:

```
H(z) = (Kp + Ki/(1-z^-1)) ¬∑ 1/(1 + (Kp + Ki/(1-z^-1)))
```

### –ü–æ–ª–æ—Å–∞ –ø–µ—Ç–ª–∏ (Loop Bandwidth)

```
Bn ‚âà (Kp + Ki/4) / (2œÄ)
```

–¢–∏–ø–∏—á–Ω–æ: `Bn = 0.01...0.05` –æ—Ç —Å–∏–º–≤–æ–ª—å–Ω–æ–π —á–∞—Å—Ç–æ—Ç—ã

### –í—Ä–µ–º—è —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏

```
T_settling ‚âà 4 / (2œÄ¬∑Bn)
```

–î–ª—è `Bn = 0.01`: `T_settling ‚âà 64` —Å–∏–º–≤–æ–ª–∞

### –£—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å

–ö—Ä–∏—Ç–µ—Ä–∏–π –ù–∞–π–∫–≤–∏—Å—Ç–∞: `Kp + Ki/2 < 1`

---

## –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫

–ü–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º –ø—Ä–æ–≤–µ—Ä—å—Ç–µ:

- [ ] –í—ã–±—Ä–∞–Ω –ø–æ–¥—Ö–æ–¥—è—â–∏–π –º–µ—Ç–æ–¥ –¥–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
- [ ] –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã Kp –∏ Ki –≤ —Ä–∞–∑—É–º–Ω—ã—Ö –ø—Ä–µ–¥–µ–ª–∞—Ö
- [ ] freq_limit –±–æ–ª—å—à–µ –æ–∂–∏–¥–∞–µ–º–æ–≥–æ —Å–¥–≤–∏–≥–∞
- [ ] –°–∏–≥–Ω–∞–ª –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω (std ‚âà 1)
- [ ] –ü—Ä–∏–º–µ–Ω–µ–Ω–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è (RRC –∏ —Ç.–¥.)
- [ ] –§–∞–∑–∞ –≤—ã—Ä–æ–≤–Ω–µ–Ω–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–µ–∞–º–±—É–ª–∞)

---

## –≠–∫—Å–ø—Ä–µ—Å—Å-—Ç–µ—Å—Ç

```python
# –°–æ–∑–¥–∞—ë–º —Ç–µ—Å—Ç–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª —Å –∏–∑–≤–µ—Å—Ç–Ω—ã–º —Å–¥–≤–∏–≥–æ–º
np.random.seed(42)
symbols = np.random.choice([1+1j, 1-1j, -1+1j, -1-1j], 1000)
signal = np.repeat(symbols, 4)  # sps=4

# –î–æ–±–∞–≤–ª—è–µ–º —Å–¥–≤–∏–≥ 1%
f_offset = 0.01
n = np.arange(len(signal))
signal_shifted = signal * np.exp(1j * 2 * np.pi * f_offset * n)

# –¢–µ—Å—Ç–∏—Ä—É–µ–º FLL
fll = FrequencyLockedLoop(Kp=0.001, Ki=0.00005)
_, f_est = fll.process_signal(signal_shifted)

# –ü—Ä–æ–≤–µ—Ä–∫–∞
error = abs(f_est - f_offset)
print(f"–ò—Å—Ç–∏–Ω–Ω—ã–π —Å–¥–≤–∏–≥: {f_offset}")
print(f"–û—Ü–µ–Ω–∫–∞ FLL:     {f_est:.6f}")
print(f"–û—à–∏–±–∫–∞:         {error:.6f}")
print(f"‚úÖ PASS" if error < 0.001 else "‚ùå FAIL")
```

---

## –°—Å—ã–ª–∫–∏

- **–ü–æ–ª–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è:** `FLL_GUIDE.md`
- **–ö–æ–¥:** `fll.py`
- **–ü—Ä–∏–º–µ—Ä—ã:** `fll_real_signal.py`

---

*–®–ø–∞—Ä–≥–∞–ª–∫–∞ FLL v1.0*

